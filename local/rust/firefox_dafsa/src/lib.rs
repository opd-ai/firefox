/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! Rust implementation of DAFSA (Deterministic Acyclic Finite State Automaton)
//!
//! This is a port of the C++ Dafsa class from xpcom/ds/Dafsa.{h,cpp}.
//! The implementation maintains API compatibility with the C++ version.

pub mod ffi;

/// The value returned when a key is not found in the DAFSA.
pub const KEY_NOT_FOUND: i32 = -1;

/// A deterministic acyclic finite state automaton suitable for storing static
/// dictionaries of tagged ASCII strings.
///
/// The DAFSA is initialized with a binary encoding generated by `make_dafsa.py`.
pub struct Dafsa {
    data: Vec<u8>,
}

impl Dafsa {
    /// Creates a new DAFSA with the given binary data.
    ///
    /// # Arguments
    /// * `data` - Binary encoding generated by `make_dafsa.py`
    pub fn new(data: Vec<u8>) -> Self {
        Dafsa { data }
    }

    /// Creates a DAFSA from a slice (used for FFI).
    pub fn from_slice(data: &[u8]) -> Self {
        Dafsa {
            data: data.to_vec(),
        }
    }

    /// Searches for the given string in the DAFSA.
    ///
    /// # Arguments
    /// * `key` - The string to search for
    ///
    /// # Returns
    /// * `KEY_NOT_FOUND` if not found, otherwise the associated tag
    pub fn lookup(&self, key: &str) -> i32 {
        lookup_string(&self.data, key.as_bytes())
    }
}

/// Read next offset from pos.
/// Returns Some(offset) if an offset could be read, None otherwise.
fn get_next_offset(pos: &mut usize, end: usize, offset: &mut usize, data: &[u8]) -> bool {
    if *pos >= end {
        return false;
    }

    // When reading an offset the byte array must always contain at least
    // three more bytes to consume. First the offset to read, then a node
    // to skip over and finally a destination node. No object can be smaller
    // than one byte.
    debug_assert!(*pos + 2 < end);

    let bytes_consumed;
    match data[*pos] & 0x60 {
        0x60 => {
            // Read three byte offset
            *offset += (((data[*pos] & 0x1F) as usize) << 16)
                | ((data[*pos + 1] as usize) << 8)
                | (data[*pos + 2] as usize);
            bytes_consumed = 3;
        }
        0x40 => {
            // Read two byte offset
            *offset += (((data[*pos] & 0x1F) as usize) << 8) | (data[*pos + 1] as usize);
            bytes_consumed = 2;
        }
        _ => {
            *offset += (data[*pos] & 0x3F) as usize;
            bytes_consumed = 1;
        }
    }

    if (data[*pos] & 0x80) != 0 {
        *pos = end;
    } else {
        *pos += bytes_consumed;
    }
    true
}

/// Check if byte at offset is last in label.
#[inline]
fn is_eol(offset: usize, data: &[u8]) -> bool {
    debug_assert!(offset < data.len());
    (data[offset] & 0x80) != 0
}

/// Check if byte at offset matches first character in key.
/// This version matches characters not last in label.
#[inline]
fn is_match(offset: usize, key_byte: u8, data: &[u8]) -> bool {
    debug_assert!(offset < data.len());
    data[offset] == key_byte
}

/// Check if byte at offset matches first character in key.
/// This version matches characters last in label.
#[inline]
fn is_end_char_match(offset: usize, key_byte: u8, data: &[u8]) -> bool {
    debug_assert!(offset < data.len());
    data[offset] == (key_byte | 0x80)
}

/// Read return value at offset.
/// Returns Some(value) if a return value could be read, None otherwise.
fn get_return_value(offset: usize, data: &[u8]) -> Option<i32> {
    debug_assert!(offset < data.len());
    if (data[offset] & 0xE0) == 0x80 {
        Some((data[offset] & 0x0F) as i32)
    } else {
        None
    }
}

/// Lookup a domain key in a byte array generated by make_dafsa.py.
/// The rule type is returned if key is found, otherwise KEY_NOT_FOUND is returned.
fn lookup_string(graph: &[u8], key: &[u8]) -> i32 {
    let mut pos = 0;
    let end = graph.len();
    let mut offset = 0;
    let mut key_idx = 0;
    let key_end = key.len();

    while get_next_offset(&mut pos, end, &mut offset, graph) {
        //   char <char>+ end_char offsets
        //   char <char>+ return value
        //   char end_char offsets
        //   char return value
        //   end_char offsets
        //   return_value
        let mut did_consume = false;

        if key_idx < key_end && !is_eol(offset, graph) {
            // Leading <char> is not a match. Don't dive into this child
            if !is_match(offset, key[key_idx], graph) {
                continue;
            }
            did_consume = true;
            offset += 1;
            key_idx += 1;

            // Possible matches at this point:
            // <char>+ end_char offsets
            // <char>+ return value
            // end_char offsets
            // return value
            // Remove all remaining <char> nodes possible
            while !is_eol(offset, graph) && key_idx < key_end {
                if !is_match(offset, key[key_idx], graph) {
                    return KEY_NOT_FOUND;
                }
                key_idx += 1;
                offset += 1;
            }
        }

        // Possible matches at this point:
        // end_char offsets
        // return_value
        // If one or more <char> elements were consumed, a failure
        // to match is terminal. Otherwise, try the next node.
        if key_idx == key_end {
            if let Some(return_value) = get_return_value(offset, graph) {
                return return_value;
            }
            // The DAFSA guarantees that if the first char is a match, all
            // remaining char elements MUST match if the key is truly present.
            if did_consume {
                return KEY_NOT_FOUND;
            }
            continue;
        }

        if !is_end_char_match(offset, key[key_idx], graph) {
            if did_consume {
                return KEY_NOT_FOUND; // Unexpected
            }
            continue;
        }

        key_idx += 1;
        offset += 1;
        pos = offset; // Dive into child
    }

    KEY_NOT_FOUND // No match
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test data would normally come from make_dafsa.py
    // For now, we'll test basic functionality

    #[test]
    fn test_key_not_found_empty() {
        let dafsa = Dafsa::new(vec![]);
        assert_eq!(dafsa.lookup("test"), KEY_NOT_FOUND);
    }

    #[test]
    fn test_key_not_found_simple() {
        // Minimal valid DAFSA that won't match anything
        // Real test data should come from the C++ test fixtures
        let dafsa = Dafsa::new(vec![]);
        assert_eq!(dafsa.lookup(""), KEY_NOT_FOUND);
        assert_eq!(dafsa.lookup("foo"), KEY_NOT_FOUND);
    }
}
